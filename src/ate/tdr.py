""" 
The Module 'tdr' short for 'Test Data Record' provides the needed utilities to handle recorded test results
from the generated csv file of the ATE test software.
"""
from __future__ import annotations

import pandas as pd
from pandas import DataFrame
import re
from ate.pcf import Pcf
from kemx.templates import Record

DATE_COLUMN_NAME = '[TIME] TIMESTAMP / RECORD ID'
SERIAL_COLUMN_NAME = '[CONFIG] UUT SERIAL NUMBER'

class TdrsCsv:

    """A class to define an interface for a Test Data Record Csv file

    Attributes
    ----------
    csv_path : str
        test data record csv relative or abs path
    test_spec : Pcf.Section
        Pcf (Product config file) test spec section object

    Properties
    ----------
    records : list[TestDataRecord]
        parses Dataframe rows into TestDataRecord objects in a list
    df : Dataframe
        Dataframe from csv_path

    Methods
    -------
    get_last_record()
        Retrieves the last record in csv by datetime
    """

    def __init__(self, csv_path: str, test_spec: Pcf.Section) -> None:
        """Constructor for TdrsCsv class

        Parameters
        ----------
        csv_path : str
            test data record csv relative or abs path
        test_spec : Pcf.Section
            Pcf (Product config file) test spec section object
        """
        self.csv_path = csv_path
        self.test_spec = test_spec

    
    @property
    def df(self) -> DataFrame:
        """ real time updateded Dataframe representation of the TdrsCsv data

        Returns
        -------
        DataFrame
            converts its str date format into datetime format after return
        """
        temp_df = pd.read_csv(self.csv_path, sep=',')
        temp_df[DATE_COLUMN_NAME] = pd.to_datetime(temp_df[DATE_COLUMN_NAME], format='%Y-%m-%d_%H:%M:%S.%f')
        return temp_df


    @property
    def records(self) -> list[TestDataRecord]:
        """list of each Record of the Csv in form of TestDataRecord object

        Returns
        -------
        list[TestDataRecord]
            every row of the Dataframe property is converted into TestDataRecord
        """
        return [self.TestDataRecord(self.df.iloc[idx]) for idx in self.df.index]

    def get_last_record(self) -> TestDataRecord:
        """last csv record by recorded datetime

        Returns
        -------
        TestDataRecord
            locates by index of the maximum record date
        """
        return self.TestDataRecord(self.df.iloc[self.df[DATE_COLUMN_NAME].argmax()])
    
    
    class TestDataRecord(Record):
        """Describes record (row) of csv file, the record contains all the
        information generated by a finished test sequence

        Attributes
        ----------
        csv : TdrsCsv
            Test Dara Records Csv object 
        data : pd.Series
            asdad
        date : Datetime
            asdad
        serial : str
            asdad
        
        Properties
        ----------
        status : bool
            adasd
        
        Methods
        -------
        build_failstring()
            asdad

        """
        def __init__(self, data: pd.Series) -> None:
            """_summary_

            Parameters
            ----------
            csv : TdrsCsv
                upper nested class, in this case, TdrsCsv object
            data : pd.Series
                reocord data as Pandas Series
            """
            self.csv = super(TdrsCsv.TestDataRecord, self)
            self.data = data
            self.date = data.get(DATE_COLUMN_NAME)
            self.serial = data.get(SERIAL_COLUMN_NAME)
            self._status = None

        
        @property
        def status(self) -> bool:
            """test result of the UUT (unit under test) PASS or FAIL

            Returns
            -------
            bool
                parses string result to bool, if its the first time 
                calling this property, deletes value from data series,
                to avoid being used as a single test
            """
            if "[RESULT] TEST P/F STATUS" in self.data:
                try:
                    self._status = True if self.data["[RESULT] TEST P/F STATUS"] == 'PASS' else False
                    return self._status
                finally:
                    self.data = self.data.drop("[RESULT] TEST P/F STATUS")
            else:
                return self._status
        
        def _get_failed_tests(self) -> list[Test]:
            return [test for test in self.tests if "FAIL" in str(test.data)]

        def build_failstring(self):
            """failstring in kemx traz system format
            to analyze PCB failures

            Returns
            -------
            _type_
                _description_
            """
            failstring: str = ""
            for test in self._get_failed_tests():
                failstring += '|ftestres=0,{},{},{},{},{},{},{}\n'. \
                    format(
                        test.name,
                        test.meas,
                        test.high_limit,
                        test.low_limit,
                        test.nominal,
                        test.units,
                        test.operator
                        )

            return failstring
        
        def __repr__(self) -> str:
            return self.data.__repr__()
        
        class Test(Record.Test):

            """
            Describes single specific test, where each test is contained in a Record
            """

            def __init__(self, outer: TdrsCsv.TestDataRecord, name: str, data: str) -> None:
                self._name = name
                self.data = data
                self.operator = None
                self.record = outer
                self.spec: Pcf.TestSpecSection.SingleTestSpec = self.record.csv.test_spec[self.name]



            @property
            def name(self) -> str:
                if  '[' in self._name:
                    return re.split(r' \[', self._name)[0]
                else:
                    return self._name
            
            @property
            def status(self) -> bool:
                return True if 'PASS' in self.data else False
                
            @property
            def type(self) -> str:
                return self.spec.data_type
            
            @property
            def nominal(self):
                 return self.spec.nominal
            
            @property
            def units(self) -> str:
                return self.spec.units
            
            @property
            def low_limit(self):
                return self.spec.low_limit
            
            @property
            def high_limit(self):
                return self.spec.high_limit
            
            @property
            def meas(self):
                if self.type == "DBL":
                    try:
                        self.operator = '<>'
                        return self.record[f'{self.name} [MEAS]'].data
                    except KeyError:
                        if self.nominal in (1.0, 0.0):
                            self.operator = '=='
                            return int(not self.nominal)
                        else:
                            return None
                elif self.type == "BOOLEAN":
                    self.operator = '=='
                    return int(self.status)
                elif self.type == "STRING":
                    self.operator = '=='
                    pass #TODO: implement value for string test type
                    
                elif self.type == "CORRELATION DBL":
                    self.operator = '<>'
                    pass #TODO: implement value for CORRELATION DBL test type

